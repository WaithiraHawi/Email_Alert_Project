# File: config.py
# Configuration file for the backend platform

class Config:
    # Database configuration
    SQLALCHEMY_DATABASE_URI = 'sqlite:///transactions.db'  # Using SQLite for simplicity
    SQLALCHEMY_TRACK_MODIFICATIONS = False  # Disabling event notifications for SQLAlchemy

    # Email server configuration
    MAIL_SERVER = 'smtp.gmail.com'  # Using Gmail's SMTP server
    MAIL_PORT = 587  # Port for TLS/STARTTLS
    MAIL_USE_TLS = True  # Enabling encryption for email
    MAIL_USERNAME = 'waithirak.dorothy@gmail.com'  # Sender's email address
    MAIL_PASSWORD = 'your_password'  # Password or app-specific key for Gmail
    MAIL_DEFAULT_SENDER = 'waithirak.dorothy@gmail.com'  # Default sender email address

# File: models.py
# Defines the database schema for the application

from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()  # Initialize SQLAlchemy instance

class Transaction(db.Model):
    # Model for storing transaction information
    id = db.Column(db.Integer, primary_key=True)  # Primary key for each transaction
    user_email = db.Column(db.String(120), nullable=False)  # User's email address
    status = db.Column(db.String(20), default='pending')  # Status of the transaction
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)  # Timestamp of transaction creation

# File: email_service.py
# Handles the sending of email notifications

from flask_mail import Mail, Message

mail = Mail()  # Initialize Flask-Mail instance

def send_email(subject, recipients, body):
    """
    Function to send an email
    :param subject: Email subject
    :param recipients: List of recipient email addresses
    :param body: Body of the email
    """
    msg = Message(subject, recipients=recipients, body=body)
    mail.send(msg)  # Send the email

# File: app.py
# Main application file containing routes and transaction monitoring logic

from flask import Flask, request, jsonify
from config import Config
from models import db, Transaction
from email_service import mail, send_email
from datetime import datetime, timedelta
import threading
import time

app = Flask(__name__)  # Initialize Flask app
app.config.from_object(Config)  # Load configuration

db.init_app(app)  # Bind SQLAlchemy to app
mail.init_app(app)  # Bind Flask-Mail to app

@app.route('/transaction', methods=['POST'])
def create_transaction():
    """
    API endpoint to create a new transaction.
    Expects a JSON body with 'user_email'.
    """
    data = request.json
    if 'user_email' not in data:
        return jsonify({'error': 'user_email is required'}), 400  # Validation error
    
    transaction = Transaction(user_email=data['user_email'])
    db.session.add(transaction)  # Add transaction to the database
    db.session.commit()  # Save changes
    return jsonify({'message': 'Transaction created', 'id': transaction.id}), 201

@app.route('/transactions', methods=['GET'])
def list_transactions():
    """
    API endpoint to retrieve all transactions.
    Returns a list of transactions with their details.
    """
    transactions = Transaction.query.all()
    return jsonify([{
        'id': t.id,
        'user_email': t.user_email,
        'status': t.status,
        'timestamp': t.timestamp.isoformat()
    } for t in transactions])

def monitor_transactions():
    """
    Background thread function to monitor pending transactions.
    Sends an email alert if a transaction remains pending for more than 45 seconds.
    """
    with app.app_context():  # Required for accessing app context in threads
        while True:
            pending_transactions = Transaction.query.filter_by(status='pending').all()
            for transaction in pending_transactions:
                if datetime.utcnow() - transaction.timestamp > timedelta(seconds=45):
                    send_email(
                        subject="Transaction Delayed",
                        recipients=[transaction.user_email],
                        body=f"Your transaction (ID: {transaction.id}) has been delayed."
                    )
                    transaction.status = 'delayed'  # Update transaction status
                    db.session.commit()  # Save changes
            time.sleep(10)  # Check every 10 seconds

if __name__ == '__main__':
    # Create the database tables if they don't exist
    with app.app_context():
        db.create_all()
    # Start the transaction monitor thread
    threading.Thread(target=monitor_transactions, daemon=True).start()
    # Run the Flask app
    app.run(debug=True)

# File: simulate.py
# Script to simulate creating and testing transactions

import requests
import time

BASE_URL = 'http://127.0.0.1:5000'  # URL of the backend server

# Sample user emails to simulate transactions
sample_emails = [
    'waithirak.dorothy@gmail.com',
    'dorotttyyy@gmail.com',
    'waithirak.kdorothy@gmail.com'
]

# Create sample transactions
for email in sample_emails:
    response = requests.post(f'{BASE_URL}/transaction', json={'user_email': email})
    print(response.json())  # Print the response from the server

# Wait for 60 seconds to allow alerts for delayed transactions
time.sleep(60)

# Retrieve and print all transactions
response = requests.get(f'{BASE_URL}/transactions')
print("All Transactions:")
print(response.json())

python app.py
python simulate.py

{'message': 'Transaction created', 'id': 1}
{'message': 'Transaction created', 'id': 2}
{'message': 'Transaction created', 'id': 3}
All Transactions:
[
    {'id': 1, 'user_email': 'waithirak.dorothy@gmail.com', 'status': 'delayed', 'timestamp': '2024-11-22T12:34:56'},
    {'id': 2, 'user_email': 'dorotttyyy@gmail.com', 'status': 'delayed', 'timestamp': '2024-11-22T12:34:56'},
    {'id': 3, 'user_email': 'waithirak.kdorothy@gmail.com', 'status': 'delayed', 'timestamp': '2024-11-22T12:34:56'}
]
