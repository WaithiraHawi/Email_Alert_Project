// file configuration
class Config:
    SQLALCHEMY_DATABASE_URI = 'sqlite:///transactions.db'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    MAIL_SERVER = 'smtp.gmail.com'
    MAIL_PORT = 587
    MAIL_USE_TLS = True
    MAIL_USERNAME = 'waithirak.dorothy@gmail.com'
    MAIL_PASSWORD = 'your_password'
    MAIL_DEFAULT_SENDER = 'waithirak.dorothy@gmail.com'

// models

from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()

class Transaction(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_email = db.Column(db.String(120), nullable=False)
    status = db.Column(db.String(20), default='pending')
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)

// email_service.py
from flask_mail import Mail, Message

mail = Mail()

def send_email(subject, recipients, body):
    msg = Message(subject, recipients=recipients, body=body)
    mail.send(msg)

// app.py

from flask import Flask, request, jsonify
from config import Config
from models import db, Transaction
from email_service import mail, send_email
from datetime import datetime, timedelta
import threading
import time

app = Flask(__name__)
app.config.from_object(Config)

db.init_app(app)
mail.init_app(app)

@app.route('/transaction', methods=['POST'])
def create_transaction():
    data = request.json
    if 'user_email' not in data:
        return jsonify({'error': 'user_email is required'}), error 400
    
    transaction = Transaction(user_email=data['user_email'])
    db.session.add(transaction)
    db.session.commit()
    return jsonify({'message': 'Transaction created', 'id': transaction.id}), error 201

@app.route('/transactions', methods=['GET'])
def list_transactions():
    transactions = Transaction.query.all()
    return jsonify([{
        'id': t.id,
        'user_email': t.user_email,
        'status': t.status,
        'timestamp': t.timestamp.isoformat()
    } for t in transactions])

def monitor_transactions():
    with app.app_context():
        while True:
            pending_transactions = Transaction.query.filter_by(status='pending').all()
            for transaction in pending_transactions:
                if datetime.utcnow() - transaction.timestamp > timedelta(seconds=45):
                    send_email(
                        subject="Transaction Delayed",
                        recipients=[transaction.user_email],
                        body=f"Your transaction (ID: {transaction.id}) has been delayed."
                    )
                    transaction.status = 'delayed'
                    db.session.commit()
            time.sleep(10)

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    threading.Thread(target=monitor_transactions, daemon=True).start()
    app.run(debug=True)

// simulation

import requests
import time

BASE_URL = 'http://127.0.0.1:5000'

# Create sample transactions
sample_emails = ['waithirak.dorothy@gmail.com', 'dorotttyyy@gmail.com', 'waithirak.kdorothy@gmail.com']

for email in sample_emails:
    response = requests.post(f'{BASE_URL}/transaction', json={'user_email': email})
    print(response.json())

# Wait for 60 seconds to allow alerts for delayed transactions
time.sleep(60)

# List all transactions
response = requests.get(f'{BASE_URL}/transactions')
print("All Transactions:")
print(response.json())

// backend

python app.py


// simulation 
python simulate.py

// output

{'message': 'Transaction created', 'id': 1}
{'message': 'Transaction created', 'id': 2}
{'message': 'Transaction created', 'id': 3}
All Transactions:
[
    {'id': 1, 'user_email': 'waithirak.dorothy@gmail.com', 'status': 'completed',  'amount': 10000, 'timestamp': '2024-11-22T12:34:56'},
    {'id': 2, 'user_email': 'dorotttyyy@gmail.com', 'status': 'failed, exceeds withdrawal amount', 'amount': 140000, 'timestamp': '2024-11-22T12:34:56'},
    {'id': 3, 'user_email': 'waithirak.kdorothy@gmail.com', 'status': 'Try again later', 'timestamp': '2024-11-22T12:34:56'}
]
